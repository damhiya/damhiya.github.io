<!DOCTYPE html>
<html><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script>document.addEventListener("DOMContentLoaded", () => {[...document.getElementsByClassName("math display")].forEach( element =>katex.render(element.textContent, element, {throwOnError: false, displayMode: true}));
[...document.getElementsByClassName("math inline")].forEach( element =>katex.render(element.textContent, element, {throwOnError: false, displayMode: false}));});</script>

<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/syntax.css">
<title> Curry&#39;s-Paradox</title>
</head>
<body><div class="page-wrapper"><!--
Date : 2021.8.1
-->
<p>λ-calculus, turing machine 등의 주제를 논할 때에는 항상 프로그램의 정지 여부에 관한 문제가 따라 나온다. 정지하는 프로그램을 판별하는 일은 커리-하워드 대응과 결부할 때 더욱 중요한데, 종료하지 않는 프로그램을 허용하는 것은 곧 논리체계가 inconsistent 함을 의미하기 때문이다. 이 글 에서는 이런 non-termination을 유발할 수 있는 요소 중 하나인 Curry's paradox에 대해 설명한다.</p>
<h2 id="untyped-λ-calculuss-y-combinator">Untyped λ-calculus's Y combinator</h2>
<p>Untyped λ-calculus의 유용성을 가장 단적으로 보여주는 예시는 바로 Y combinator이다. <span class="math display">
  Y \equiv \lambda f . (\lambda x . f (x x)) (\lambda x . f (x x))
</span></p>
<p><span class="math inline">Y f</span>와 <span class="math inline">f (Y f)</span>를 한번 계산해보자. <span class="math display">
  \begin{array}{rl}
                    &amp; Y f                                             \\
    \longrightarrow &amp; (\lambda x . f (x x)) (\lambda x . f (x x))     \\
    \longrightarrow &amp; f ((\lambda x . f (x x)) (\lambda x . f (x x))) \\
  \end{array}
</span> <span class="math display">
  \begin{array}{rl}
                    &amp; f (Y f)                                         \\
    \longrightarrow &amp; f ((\lambda x . f (x x)) (\lambda x . f (x x))) \\
  \end{array}
</span> 즉 <span class="math inline">Y f = f (Y f)</span>를 만족한다. (여기서 등호 기호는 β-equivalence를 뜻 한다. <span class="math inline">Y f</span>와 <span class="math inline">f (Y f)</span>가 β-equivalent 하긴 하지만 <span class="math inline">Y f</span> 가 <span class="math inline">f (Y f)</span> 로 β-reduce되는 것은 아니다.)</p>
<p>수학에서는 <span class="math inline">Y f</span> 와 같이 <span class="math inline">x = f(x)</span> 를 만족하는 <span class="math inline">x</span>를 <span class="math inline">f</span>의 fixed point (혹은 그냥 fixpoint) 라고 부른다. 즉 <span class="math inline">Y</span>는 임의의 함수 <span class="math inline">f</span>를 인자로 받아서 <span class="math inline">f</span>의 fixpoint <span class="math inline">Y f</span>를 결과로 주는 고차함수라고 이해할 수 있다. 이처럼 <span class="math inline">\operatorname{fix} f = f (\operatorname{fix} f)</span>를 만족하는 <span class="math inline">\operatorname{fix}</span>를 fixpoint combinator라고 부르며, fixpoint combinator에는 <span class="math inline">Y</span> 말고도 여러가지가 있다.</p>
<p>fixpoint combinator가 무엇인지 직관적인 이해가 잘 안된다면 아래와 같이 iterative하게 생각해 보는 것이 도움이 될지도 모르겠다. <span class="math display">
  \begin{array}{rl}
                    &amp; Y f                                             \\
    \longrightarrow &amp; (\lambda x . f (x x)) (\lambda x . f (x x))     \\
    \longrightarrow &amp; f ((\lambda x . f (x x)) (\lambda x . f (x x))) \\
    \longrightarrow &amp; f (f ((\lambda x . f (x x)) (\lambda x . f (x x)))) \\
    \longrightarrow &amp; f (f (f ((\lambda x . f (x x)) (\lambda x . f (x x))))) \\
    \longrightarrow &amp; f (f (f (f (\ldots)))) \\
  \end{array}
</span></p>
<p>fixpoint combinator가 왜 중요할까? fixpoint combinator가 있으면 재귀함수를 만들 수 있기 때문이다. 다음은 하스켈에서 fixpoint combinator를 사용해 팩토리얼 함수를 작성한 것이다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> f (fix f)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> fix <span class="op">$</span> \f n <span class="ot">-&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> n <span class="op">*</span> f (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>그런데 <span class="math inline">Y</span>를 사용하면 종료하지 않는 계산을 만들 수 있다. <span class="math display">
  I \equiv \lambda x . x
</span> <span class="math display">
  \begin{array}{rl}
                   &amp; YI    \\
    \longrightarrow&amp; I(YI) \\
    \longrightarrow&amp; YI
  \end{array}
</span></p>
<p><span class="math inline">YI</span> 는 β-reduction을 아무리 수행하여도 β normal form에 도달할 수 없다. 이는 untyped λ-calculus에서 weak normalization property가 성립하지 않음을 의미한다. 사실 더 단순한 예시로 <span class="math inline">\Omega</span>가 있다. <span class="math display">
  \begin{array}{rrl}
    \Omega &amp;          \equiv &amp; (\lambda x . x x) (\lambda x . x x) \\
           &amp; \longrightarrow &amp; (\lambda y . y y) (\lambda x . x x) \\
           &amp; \longrightarrow &amp; (y y) [y := \lambda x . x x]        \\
           &amp; \longrightarrow &amp; (\lambda x . x x) (\lambda x . x x)
  \end{array}
</span></p>
<p>fixpoint combinator에게 타입을 붙여보면 애초에 논리적으로 말이 되지 않음을 알 수 있다. 하스켈에서 <code>fix</code>는 다음과 같은 타입을 갖는다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> ∀ α<span class="op">.</span> (α → α) → α</span></code></pre></div>
<p>Propositions as types의 관점에서 볼 때, 이는 "<span class="math inline">P</span> 일 때 <span class="math inline">P</span> 라면, <span class="math inline">P</span> 이다"를 의미한다. Tautology에서 임의의 명제를 증명해 낼 수 있는 것이다. 따라서 이런 fixpoint를 가지는 논리체계는 inconsistent 하다.</p></div>
</body>
</html>
